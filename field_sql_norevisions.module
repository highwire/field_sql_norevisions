<?php

/**
 * @file
 * Default implementation of the field storage API.
 */

/**
 * Implements hook_help().
 */
function field_sql_norevisions_help($path, $arg) {
  switch ($path) {
    case 'admin/help#field_sql_norevisions':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Field SQL storage module stores field data in the database. It is based the default field storage module. It does not save field revisons.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_menu()
 */
function field_sql_norevisions_menu() {
  $items = array();

  $items['admin/config/system/field_sql_norevisions'] = array(
    'title' => 'Field sql norevisions',
    'description' => 'Adjust Field SQL Norevisions settings.',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer site configuration'),
    'position' => 'left',
    'file' => 'system.admin.inc',
    'file path' => 'modules/system/',
  );

  $items['admin/config/system/field_sql_norevisions/field_sql_norevisions_entity_settings'] = array(
    'title' => 'Field SQL Norevisions Entity Settings settings',
    'description' => 'Enable or disable field norevisions for entities/bundles',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('field_sql_norevisions_entity_settings_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/system/field_sql_norevisions/field_sql_norevisions_batch_delete'] = array(
    'title' => 'Field SQL Norevisions Batch Delete',
    'description' => 'Delete revisions for entities',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('field_sql_norevisions_batch_delete_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Form callback for batch deletion of revisions
 */
function field_sql_norevisions_batch_delete_form($form, &$form_state) {
  $form = array();

  $entity_info = entity_get_info();

  $defaults = variable_get('field_sql_norevisions_enabled_entities', array());

  foreach ($entity_info as $entity_name => $entity) {
    //First we check if it's fieldable, we don't care about it if it's not
    if(!$entity['fieldable']) continue;

    $form['field_sql_norevisions_' . $entity_name .'_wrapper'] = array(
      '#type' => 'fieldset',
      '#title' => t('Delete revisions for <strong>'.$entity['label'].'</strong> entity bundles'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );

    foreach ($entity['bundles'] as $bundle_name => $bundle) {
      $form['field_sql_norevisions_' . $entity_name .'_wrapper']['field_sql_norevisions_'.$entity_name.'_'.$bundle_name.'_delete'] = array(
        '#type' => 'checkbox',
        '#title' => t('Delete '. $bundle['label'] . ' revisions.'),
      );
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Delete'),
  );

  return $form;
}

function field_sql_norevisions_batch_delete_form_submit($form, &$form_state) {
  $batch = array();
  $batch['finished'] = 'field_sql_norevisions_batch_revision_delete_finish';

  $entity_info = entity_get_info();

  foreach ($entity_info as $entity_name => $entity) {
    foreach ($entity['bundles'] as $bundle => $bundle_settings) {
      if(!empty($form_state['values']['field_sql_norevisions_'.$entity_name.'_'.$bundle.'_delete'])) {
        $fields = field_info_instances($entity_name, $bundle);
        foreach ($fields as $field) {
          $field_info = field_info_field($field['field_name']);
          if($revisions_table = _field_sql_storage_revision_tablename($field_info)) {
            $batch['operations'][] = array('field_sql_norevisions_batch_delete_revisions', array($revisions_table, $bundle));
          }
        }
      }
    }
  }

  if(!empty($batch['operations'])) {
    batch_set($batch);
  } else {
    drupal_set_message("No entities selected, no revisions deleted.");
  }

}


/**
 * Batch revision delete callback
 */
function field_sql_norevisions_batch_delete_revisions($field, $bundle, &$context) {
   db_delete($field)
            ->condition('bundle', $bundle)
            ->execute();
}


/**
 * Form callback admin/config/system/field_sql_norevisions
 *
 * Settings form that will get all entities and bundles (if supported) and allow you to enable of disable revisions
 */
function field_sql_norevisions_entity_settings_form($form, &$form_state) {
  $form = array();

  $form['markup'] = array(
    '#markup' => t('<strong>Please NOTE that if any of your entity bundles are sharing fields, it is required that both entities/bundles have no revisions.</strong>'),
  );

  $entity_info = entity_get_info();

  $defaults = variable_get('field_sql_norevisions_enabled_entities', array());

  foreach ($entity_info as $entity_name => $entity) {
    //First we check if it's fieldable, we don't care about it if it's not
    if(!$entity['fieldable']) continue;

    $form['field_sql_norevisions_' . $entity_name .'_wrapper'] = array(
      '#type' => 'fieldset',
      '#title' => t('Disable SQL revisions for <strong>'.$entity['label'].'</strong> entity bundles'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      '#tree' => TRUE,
    );

    foreach ($entity['bundles'] as $bundle_name => $bundle) {
      $form['field_sql_norevisions_' . $entity_name .'_wrapper']['field_sql_norevisions_'.$entity_name.'_'.$bundle_name.'_enabled'] = array(
        '#type' => 'checkbox',
        '#title' => t($bundle['label']),
        '#default_value' => isset($defaults['field_sql_norevisions_'.$entity_name.'_'.$bundle_name.'_enabled']) ? $defaults['field_sql_norevisions_'.$entity_name.'_'.$bundle_name.'_enabled'] : '',
      );
    }

  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );

  return $form;
}

function field_sql_norevisions_entity_settings_form_submit($form, &$form_state) {
  $entity_info = entity_get_info();
  $save = array();

  foreach ($entity_info as $entity_name => $entity) {
    if(isset($form_state['values']['field_sql_norevisions_' . $entity_name .'_wrapper'])) {
      $save = array_merge($save, $form_state['values']['field_sql_norevisions_' . $entity_name .'_wrapper']);
    }
  }

  variable_set('field_sql_norevisions_enabled_entities', $save);
}


/**
 * Implements hook_field_storage_info().
 */
function field_sql_norevisions_field_storage_info() {
  return array(
    'field_sql_norevisions' => array(
      'label' => t('SQL storage with no revison tables'),
      'description' => t('Stores fields in the local SQL database, using per-field tables.'),
    ),
  );
}


/**
 * Implements hook_field_storage_create_field().
 */
function field_sql_norevisions_field_storage_create_field($field) {
  //Still create the revision table so you can turn it on off.
  $schema = _field_sql_storage_schema($field);
  foreach ($schema as $name => $table) {
    db_create_table($name, $table);
  }
  drupal_get_schema(NULL, TRUE);
}

/**
 * Implements hook_field_update_forbid().
 *
 * Forbid any field update that changes column definitions if there is
 * any data.
 */
function field_sql_norevisions_field_update_forbid($field, $prior_field, $has_data) {
  if ($has_data && $field['columns'] != $prior_field['columns']) {
    throw new FieldUpdateForbiddenException("field_sql_norevisions cannot change the schema for an existing field with data.");
  }
}

/**
 * Implements hook_field_storage_update_field().
 */
function field_sql_norevisions_field_storage_update_field($field, $prior_field, $has_data) {
  // There is no data. Re-create the tables completely.
  if (! $has_data) {

    if (Database::getConnection()->supportsTransactionalDDL()) {
      // If the database supports transactional DDL, we can go ahead and rely
      // on it. If not, we will have to rollback manually if something fails.
      $transaction = db_transaction();
    }

    try {
      $prior_schema = _field_sql_storage_schema($prior_field);
      foreach ($prior_schema as $name => $table) {
        db_drop_table($name, $table);
      }
      $schema = _field_sql_storage_schema($field);
      foreach ($schema as $name => $table) {
        db_create_table($name, $table);
      }
    }
    catch (Exception $e) {
      if (Database::getConnection()->supportsTransactionalDDL()) {
        $transaction->rollback();
      }
      else {
        // Recreate tables.
        $prior_schema = _field_sql_storage_schema($prior_field);
        foreach ($prior_schema as $name => $table) {
          if (!db_table_exists($name)) {
            db_create_table($name, $table);
          }
        }
      }
      throw $e;
    }
  }
  else {
    // There is data, so there are no column changes. Drop all the
    // prior indexes and create all the new ones, except for all the
    // priors that exist unchanged.
    $table = _field_sql_storage_tablename($prior_field);
    foreach ($prior_field['indexes'] as $name => $columns) {
      if (!isset($field['indexes'][$name]) || $columns != $field['indexes'][$name]) {
        $real_name = _field_sql_storage_indexname($field['field_name'], $name);
        db_drop_index($table, $real_name);
      }
    }
    $table = _field_sql_storage_tablename($field);
    foreach ($field['indexes'] as $name => $columns) {
      if (!isset($prior_field['indexes'][$name]) || $columns != $prior_field['indexes'][$name]) {
        $real_name = _field_sql_storage_indexname($field['field_name'], $name);
        $real_columns = array();
        foreach ($columns as $column_name) {
          $real_columns[] = _field_sql_storage_columnname($field['field_name'], $column_name);
        }
        db_add_index($table, $real_name, $real_columns);
      }
    }
  }
  drupal_get_schema(NULL, TRUE);
}

/**
 * Implements hook_field_storage_delete_field().
 */
function field_sql_norevisions_field_storage_delete_field($field) {
  // Mark all data associated with the field for deletion.
  $field['deleted'] = 0;
  $table = _field_sql_storage_tablename($field);
  db_update($table)
    ->fields(array('deleted' => 1))
    ->execute();

  // Move the table to a unique name while the table contents are being deleted.
  $field['deleted'] = 1;
  $new_table = _field_sql_storage_tablename($field);
  db_rename_table($table, $new_table);
  drupal_get_schema(NULL, TRUE);
}

/**
 * Implements hook_field_storage_load().
 */
function field_sql_norevisions_field_storage_load($entity_type, $entities, $age, $fields, $options) {
  //Check entity bundle settings.
  $enabled_entity_bundles = variable_get('field_sql_norevisions_enabled_entities', array());
  $entity_info = entity_get_info($entity_type);
  foreach ($entities as $id => $entity) {
    if(!$enabled_entity_bundles['field_sql_norevisions_' . $entity_type .'_' . $entity->{$entity_info['entity keys']['bundle']} . '_enabled']) {
      //We fall back to normal SQL storage function
      field_sql_storage_field_storage_load($entity_type, $entities, $age, $fields, $options);
      return;
    }
  }

  $field_info = field_info_field_by_ids();

  foreach ($fields as $field_id => $ids) {
    $field = $field_info[$field_id];
    $field_name = $field['field_name'];
    $table = _field_sql_storage_tablename($field);

    // If we're trying to load a revision use the array keys from the entities
    // array as these are the entity ids that we want to load
    if ($age == FIELD_LOAD_REVISION) {
      $ids = array_keys($entities);
    }
    $query = db_select($table, 't')
      ->fields('t')
      ->condition('entity_type', $entity_type)
      ->condition('entity_id', $ids, 'IN')
      ->condition('language', field_available_languages($entity_type, $field), 'IN')
      ->orderBy('delta');

    if (empty($options['deleted'])) {
      $query->condition('deleted', 0);
    }

    $results = $query->execute();

    $delta_count = array();
    foreach ($results as $row) {
      if (!isset($delta_count[$row->entity_id][$row->language])) {
        $delta_count[$row->entity_id][$row->language] = 0;
      }

      if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $delta_count[$row->entity_id][$row->language] < $field['cardinality']) {
        $item = array();
        // For each column declared by the field, populate the item
        // from the prefixed database column.
        foreach ($field['columns'] as $column => $attributes) {
          $column_name = _field_sql_storage_columnname($field_name, $column);
          $item[$column] = $row->$column_name;
        }

        // Add the item to the field values for the entity.
        $entities[$row->entity_id]->{$field_name}[$row->language][] = $item;
        $delta_count[$row->entity_id][$row->language]++;
      }
    }
  }
}

/**
 * Implements hook_field_storage_write().
 */
function field_sql_norevisions_field_storage_write($entity_type, $entity, $op, $fields) {
  $enabled_entity_bundles = variable_get('field_sql_norevisions_enabled_entities', array());
  $entity_info = entity_get_info($entity_type);

  if(empty($enabled_entity_bundles['field_sql_norevisions_' . $entity_type .'_' . $entity->{$entity_info['entity keys']['bundle']} . '_enabled'])) {
    //We fall back to normal SQL storage function
    field_sql_storage_field_storage_write($entity_type, $entity, $op, $fields);
    return;
  }

  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
  if (!isset($vid)) {
    $vid = $id;
  }

  foreach ($fields as $field_id) {
    $field = field_info_field_by_id($field_id);
    $field_name = $field['field_name'];
    $table_name = _field_sql_storage_tablename($field);

    $all_languages = field_available_languages($entity_type, $field);
    $field_languages = array_intersect($all_languages, array_keys((array) $entity->$field_name));

    // Delete and insert, rather than update, in case a value was added.
    if ($op == FIELD_STORAGE_UPDATE) {
      // Delete languages present in the incoming $entity->$field_name.
      // Delete all languages if $entity->$field_name is empty.
      $languages = !empty($entity->$field_name) ? $field_languages : $all_languages;
      if ($languages) {
        db_delete($table_name)
          ->condition('entity_type', $entity_type)
          ->condition('entity_id', $id)
          ->condition('language', $languages, 'IN')
          ->execute();
       }
    }

    // Prepare the multi-insert query.
    $do_insert = FALSE;
    $columns = array('entity_type', 'entity_id', 'revision_id', 'bundle', 'delta', 'language');
    foreach ($field['columns'] as $column => $attributes) {
      $columns[] = _field_sql_storage_columnname($field_name, $column);
    }
    $query = db_insert($table_name)->fields($columns);

    foreach ($field_languages as $langcode) {
      $items = (array) $entity->{$field_name}[$langcode];
      $delta_count = 0;
      foreach ($items as $delta => $item) {
        // We now know we have someting to insert.
        $do_insert = TRUE;
        $record = array(
          'entity_type' => $entity_type,
          'entity_id' => $id,
          'revision_id' => $vid,
          'bundle' => $bundle,
          'delta' => $delta,
          'language' => $langcode,
        );
        foreach ($field['columns'] as $column => $attributes) {
          $record[_field_sql_storage_columnname($field_name, $column)] = isset($item[$column]) ? $item[$column] : NULL;
        }
        $query->values($record);

        if ($field['cardinality'] != FIELD_CARDINALITY_UNLIMITED && ++$delta_count == $field['cardinality']) {
          break;
        }
      }
    }

    // Execute the query if we have values to insert.
    if ($do_insert) {
      $query->execute();
    }
  }
}

/**
 * Implements hook_field_storage_delete().
 *
 * This function deletes data for all fields for an entity from the database.
 */
function field_sql_norevisions_field_storage_delete($entity_type, $entity, $fields) {
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

  foreach (field_info_instances($entity_type, $bundle) as $instance) {
    if (isset($fields[$instance['field_id']])) {
      $field = field_info_field_by_id($instance['field_id']);
      field_sql_norevisions_field_storage_purge($entity_type, $entity, $field, $instance);
    }
  }
}

/**
 * Implements hook_field_storage_purge().
 *
 * This function deletes data from the database for a single field on
 * an entity.
 */
function field_sql_norevisions_field_storage_purge($entity_type, $entity, $field, $instance) {
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

  $table_name = _field_sql_storage_tablename($field);
  db_delete($table_name)
    ->condition('entity_type', $entity_type)
    ->condition('entity_id', $id)
    ->execute();
}

/**
 * Implements hook_field_storage_query().
 */
function field_sql_norevisions_field_storage_query(EntityFieldQuery $query) {
  $tablename_function = '_field_sql_storage_tablename';
  $id_key = 'entity_id';

  $table_aliases = array();
  // Add tables for the fields used.
  foreach ($query->fields as $key => $field) {
    $tablename = $tablename_function($field);
    // Every field needs a new table.
    $table_alias = $tablename . $key;
    $table_aliases[$key] = $table_alias;
    if ($key) {
      $select_query->join($tablename, $table_alias, "$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key");
    }
    else {
      $select_query = db_select($tablename, $table_alias);
      $select_query->addTag('entity_field_access');
      $select_query->addMetaData('base_table', $tablename);
      $select_query->fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));
      $field_base_table = $table_alias;
    }
    if ($field['cardinality'] != 1 || $field['translatable']) {
      $select_query->distinct();
    }
  }

  // Add field conditions. We need a fresh grouping cache.
  drupal_static_reset('_field_sql_norevisions_query_field_conditions');
  if (isset($query->fieldConditions)) {
    _field_sql_norevisions_query_field_conditions($query, $select_query, $query->fieldConditions, $table_aliases, '_field_sql_storage_columnname');
  }

  // Add field meta conditions.
  if (isset($query->fieldMetaConditions)) {
    _field_sql_norevisions_query_field_conditions($query, $select_query, $query->fieldMetaConditions, $table_aliases, '_field_sql_norevisions_query_columnname');
  }

  if (isset($query->deleted)) {
    $select_query->condition("$field_base_table.deleted", (int) $query->deleted);
  }

  // Is there a need to sort the query by property?
  $has_property_order = FALSE;
  foreach ($query->order as $order) {
    if ($order['type'] == 'property') {
      $has_property_order = TRUE;
    }
  }

  if ($query->propertyConditions || $has_property_order) {
    if (empty($query->entityConditions['entity_type']['value'])) {
      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');
    }
    $entity_type = $query->entityConditions['entity_type']['value'];
    $entity_base_table = _field_sql_norevisions_query_join_entity($select_query, $entity_type, $field_base_table);
    $query->entityConditions['entity_type']['operator'] = '=';
    foreach ($query->propertyConditions as $property_condition) {
      $query->addCondition($select_query, "$entity_base_table." . $property_condition['column'], $property_condition);
    }
  }
  foreach ($query->entityConditions as $key => $condition) {
    $query->addCondition($select_query, "$field_base_table.$key", $condition);
  }

  // Order the query.
  foreach ($query->order as $order) {
    if ($order['type'] == 'entity') {
      $key = $order['specifier'];
      $select_query->orderBy("$field_base_table.$key", $order['direction']);
    }
    elseif ($order['type'] == 'field') {
      $specifier = $order['specifier'];
      $field = $specifier['field'];
      $table_alias = $table_aliases[$specifier['index']];
      $sql_field = "$table_alias." . _field_sql_storage_columnname($field['field_name'], $specifier['column']);
      $select_query->orderBy($sql_field, $order['direction']);
    }
    elseif ($order['type'] == 'property') {
      $select_query->orderBy("$entity_base_table." . $order['specifier'], $order['direction']);
    }
  }

  return $query->finishQuery($select_query, $id_key);
}

/**
 * Adds the base entity table to a field query object.
 *
 * @param SelectQuery $select_query
 *   A SelectQuery containing at least one table as specified by
 *   _field_sql_storage_tablename().
 * @param $entity_type
 *   The entity type for which the base table should be joined.
 * @param $field_base_table
 *   Name of a table in $select_query. As only INNER JOINs are used, it does
 *   not matter which.
 *
 * @return
 *   The name of the entity base table joined in.
 */
function _field_sql_norevisions_query_join_entity(SelectQuery $select_query, $entity_type, $field_base_table) {
  $entity_info = entity_get_info($entity_type);
  $entity_base_table = $entity_info['base table'];
  $entity_field = $entity_info['entity keys']['id'];
  $select_query->join($entity_base_table, $entity_base_table, "$entity_base_table.$entity_field = $field_base_table.entity_id");
  return $entity_base_table;
}

/**
 * Adds field (meta) conditions to the given query objects respecting groupings.
 *
 * @param EntityFieldQuery $query
 *   The field query object to be processed.
 * @param SelectQuery $select_query
 *   The SelectQuery that should get grouping conditions.
 * @param condtions
 *   The conditions to be added.
 * @param $table_aliases
 *   An associative array of table aliases keyed by field index.
 * @param $column_callback
 *   A callback that should return the column name to be used for the field
 *   conditions. Accepts a field name and a field column name as parameters.
 */
function _field_sql_norevisions_query_field_conditions(EntityFieldQuery $query, SelectQuery $select_query, $conditions, $table_aliases, $column_callback) {
  $groups = &drupal_static(__FUNCTION__, array());
  foreach ($conditions as $key => $condition) {
    $table_alias = $table_aliases[$key];
    $field = $condition['field'];
    // Add the specified condition.
    $sql_field = "$table_alias." . $column_callback($field['field_name'], $condition['column']);
    $query->addCondition($select_query, $sql_field, $condition);
    // Add delta / language group conditions.
    foreach (array('delta', 'language') as $column) {
      if (isset($condition[$column . '_group'])) {
        $group_name = $condition[$column . '_group'];
        if (!isset($groups[$column][$group_name])) {
          $groups[$column][$group_name] = $table_alias;
        }
        else {
          $select_query->where("$table_alias.$column = " . $groups[$column][$group_name] . ".$column");
        }
      }
    }
  }
}


/**
 * Implements hook_field_storage_delete_revision().
 *
 * This function actually deletes the data from the database.
 */
function field_sql_norevisions_field_storage_delete_revision($entity_type, $entity, $fields) {
  // No revisions so do nothing
}

/**
 * Implements hook_field_storage_delete_instance().
 *
 * This function simply marks for deletion all data associated with the field.
 */
function field_sql_norevisions_field_storage_delete_instance($instance) {
  $field = field_info_field($instance['field_name']);
  $table_name = _field_sql_storage_tablename($field);
  db_update($table_name)
    ->fields(array('deleted' => 1))
    ->condition('entity_type', $instance['entity_type'])
    ->condition('bundle', $instance['bundle'])
    ->execute();
}

/**
 * Implements hook_field_attach_rename_bundle().
 */
function field_sql_norevisions_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {
  // We need to account for deleted or inactive fields and instances.
  $instances = field_read_instances(array('entity_type' => $entity_type, 'bundle' => $bundle_new), array('include_deleted' => TRUE, 'include_inactive' => TRUE));
  foreach ($instances as $instance) {
    $field = field_info_field_by_id($instance['field_id']);
    if ($field['storage']['type'] == 'field_sql_norevisions') {
      $table_name = _field_sql_storage_tablename($field);
      db_update($table_name)
        ->fields(array('bundle' => $bundle_new))
        ->condition('entity_type', $entity_type)
        ->condition('bundle', $bundle_old)
        ->execute();
    }
  }
}

/**
 * Implements hook_field_storage_purge_field().
 *
 * All field data items and instances have already been purged, so all
 * that is left is to delete the table.
 */
function field_sql_norevisions_field_storage_purge_field($field) {
  $table_name = _field_sql_storage_tablename($field);
  db_drop_table($table_name);
}

/**
 * Implements hook_field_storage_details().
 */
function field_sql_norevisions_field_storage_details($field) {
  $details = array();
  if (!empty($field['columns'])) {
     // Add field columns.
    foreach ($field['columns'] as $column_name => $attributes) {
      $real_name = _field_sql_storage_columnname($field['field_name'], $column_name);
      $columns[$column_name] = $real_name;
    }
    return array(
      'sql_norevisions' => array(
        FIELD_LOAD_CURRENT => array(
          _field_sql_storage_tablename($field) => $columns,
        ),
        FIELD_LOAD_REVISION => array(
          _field_sql_storage_tablename($field) => $columns,
        ),
      ),
    );
  }
}

/**
 * Implements hook_views_data()
 *
 * Field modules can implement hook_field_views_data() to override
 * the default behavior for adding fields.
 */
function field_sql_norevisions_views_data() {
  $data = array();
  foreach (field_info_fields() as $field) {
    if ($field['storage']['type'] != 'field_sql_norevisions') {
      continue;
    }

    $module = $field['module'];
    $result = (array) module_invoke($module, 'field_views_data', $field);

    if (empty($result)) {
      $result = field_views_field_default_views_data($field);
    }

    drupal_alter('field_views_data', $result, $field, $module);

    if (is_array($result)) {
      $data = drupal_array_merge_deep($result, $data);
    }
  }
  return $data;
}

/**
 * Implements hook_views_data_alter()
 *
 * Field modules can implement hook_field_views_data_views_data_alter() to
 * alter the views data on a per field basis. This is weirdly named so as
 * not to conflict with the drupal_alter('field_views_data') in
 * field_views_data.
 */
function field_sql_norevisions_views_data_alter(&$data) {
  foreach (field_info_fields() as $field) {
    if ($field['storage']['type'] != 'field_sql_norevisions') {
      continue;
    }

    $function = $field['module'] . '_field_views_data_views_data_alter';
    if (function_exists($function)) {
      $function($data, $field);
    }
  }
}

